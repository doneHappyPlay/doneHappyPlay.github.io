[{"title":"正则表达式;","date":"2017-04-17T22:45:38.000Z","path":"2017/04/18/正则表达式-1/","text":"之前学过正则表达式，但是在实际的开发中没有经常用导致又忘记了，所以将正则表达式相关的知识记录下来作为自己日常工作中使用的语法参考手册，同时让刚接触正则表达式的同学能快速入门。 快速入门什么是正则表达式在js开发中，我们经常要对符合某些特殊规则的字符进行查询或匹配，正则表达式就是用来描述这些规则的，常见的使用场景是表单验证，查询字符等。 简单例子/^1[3|5|8|4][0-9]\\d{8}$/ //手机号码的正则表达式 ^1 代表以1开头，现在中国的手机号码是以1开头的 [3|4|5|8] 紧跟在1后面的是3，4，5，8等数字，目前没有12，16...开头的手机号码，如果有了也得加上 [0-9] 表示0-9之间的数字包括0和9，也就是所有数字 \\d{8} /d跟上面的[0-9]意思相同,{8}表示重复8次 $ 表示字符串的结束,跟^恰好相反 测试正则表达式正则表达式工具:http://regexper.com 元字符 . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 字符转义如果你想查找元字符本身的话，你不能直接指定它们，因为它们会被解释成别的意思，这时你就得使用\\来取消这些字符的特殊意义。 \\ =&gt; \\\\ . =&gt; \\. * =&gt; \\* www.baidu.com =&gt; www\\.baidu\\.com c:\\Windows =&gt; c:\\\\Windows 重复正如我们之前例子中提到的，{8}表示重复8次,以下还有几种表示重复的方式 重复零次或多次 重复一次或更多次 ？重复零次或一次 {n}重复n次 {n,}重复n次或更多次 {n,m}重复n到m次 例子:Windows\\d+ 匹配Windows后面跟1个或更多数字,^\\w+匹配一行的第一个单词(或整个字符串的第一个字符串的第一个单词，具体匹配哪个意思得看选项设置) 字符类要想查找数字，数字或字母的字符集合直接用对应的元字符就可以，但是如果想匹配没有预定义元字符的字符集合，比如元音字0-5符(a,e,i,o,u)，应该怎么办？这时候就可以使用字符类来表达，方法就是在方括号中列出它们。例如： [aeiou]-----------------------匹配任何一个英文元音字母 [.?!]-------------------------匹配标点符号(.或?或!) [0-9]-------------------------匹配一位数字，等同于\\d [a-z0-9A-Z]-------------------匹配一个英文字符，等同于\\w \\(?0\\d{2}[) -]?\\d{8}----------匹配几种格式的电话号码,如(010)99998888等 \\(----------------------------(的转义 ?-----------------------------前面的(出现0次或1次 0-----------------------------0 \\d{2}-------------------------2个数字 [) -]-------------------------)或空格或-中的一个 ?-----------------------------前面的[) -]出现1次或0次 \\d{8}-------------------------8个数字 分枝条件正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种就应该当成是匹配，具体方法是用|把不同的规则分隔开。例如: 例一: 0\\d{2}-\\d{8}|0\\d{3}-d{7} -- 两种连字号分隔的电话号一种是010-99998888 另一种是0731-1234567 例二: \\d{5}} 这个表达式匹配美国的邮编美国的邮编是5位数字或者是用连字号间隔的9位数字 例子二说明了一个问题，使用分枝条件时要注意各个条件的顺序。如果例二改成\\d{5}|\\d{5}-\\d{4}的话那么就只会匹配5位的邮编(或者时9位邮编的前5位)匹配分枝条件时将从左到右的测试每个条件，如果满足了某个分枝的话，就不会去管别的分枝。 分组之前已经提到怎么重复单个字符(直接在后面加限定符就行了)，如果想要多个字符的重复就需要用到分组了，分组的使用方法就是在()内写入子表达式(也叫做分组)，然后可以指定这个子表达式重复次数，你也可以对子表达式做一些其他操作，例如: (\\d{1,3}\\.){3}\\d(1,3) ----简单的IP地址匹配,如196.168.1.123等 \\d{1,3} ----------------1到3位的数字 (\\d{1,3}\\.) ------------1到3位的数字加上英文句点作为一个整体(分组) 众所周知，IP地址中的数字不能超过255，上述示例可能出现不符合格式的IP地址，正确的IP地址: ((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?) 反义有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字之外的，其他字符都行的情况，这是就需要用到反义: \\W ----------匹配任意不是字母，数字，下划线，汉字的字符 \\S -----------匹配任意不是空白符的字符 \\D -----------匹配非数字的字符 \\B -----------匹配不是单词开头或结束的位置 [^x] ----------匹配除了以外的任意字符 [^aeiou]--------匹配除了aeiou这几个字母以外的任意字符 后向引用使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。 后向引用用于重复搜索前面某个分组匹配的文本。例如，\\1代表分组1匹配的文本。难以理解？请看示例：\\b(\\w+)\\b\\s+\\1\\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\\b(\\w+)\\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\\1)。 你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?\\w+)(或者把尖括号换成’也行：(?’Word’\\w+)),这样就把\\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\\k,所以上一个例子也可以写成这样：\\b(?\\w+)\\b\\s+\\k\\b。 零宽断言接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧： 断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。 (?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\\b\\w+(?=ing\\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配sing和danc。 (?&lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;=\\bre)\\w+\\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。 假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;=\\d)\\d{3})+\\b，用它对1234567890进行查找时结果是234567890。下面这个例子同时使用了这两种断言：(?&lt;=\\s)\\d+(?=\\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。 负向零宽断言前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词–它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样： \\b\\wq[^u]\\w\\b匹配包含后面不是字母u的字母q的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\\w\\b将会匹配下一个单词，于是\\b\\wq[^u]\\w\\b就能匹配整个Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：\\b\\wq(?!u)\\w*\\b。 零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\\d{3}(?!\\d)匹配三位数字，而且这三位数字的后面不能是数字；\\b((?!abc)\\w)+\\b匹配不包含连续字符串abc的单词。同理，我们可以用(?&lt;!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?&lt;![a-z])\\d{7}匹配前面不是小写字母的七位数字。 一个更复杂的例子：(?&lt;=&lt;(\\w+)&gt;).(?=&lt;\\/\\1&gt;)匹配不包含属性的简单HTML标签内里的内容。(?&lt;=&lt;(\\w+)&gt;)指定了这样的前缀：被尖括号括起来的单词(比如可能是) 然后是.\\(任意的字符串),最后是一个后缀(?=&lt;\\/\\1&gt;)。注意后缀里的\\/，它用到了前面提过的字符转义；\\1则是一个反向引用，引用的正是捕获的第一组，前面的(\\w+)匹配的内容，这样如果前缀实际上是的话，后缀就是了。整个表达式匹配的是和之间的内容(再次提醒，不包括前缀和后缀本身)。 注释小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\\d(?#200-249)|250-5|[01]?\\d\\d?(?#0-199)。 要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样： (?&lt;= # 断言要匹配的文本的前缀 &lt;(\\w+)&gt; # 查找尖括号括起来的字母或数字(即HTML/XML标签) ) # 前缀结束 .* # 匹配任意文本 (?= # 断言要匹配的文本的后缀 &lt;\\/\\1&gt; # 查找尖括号括起来的内容：前面是一个&quot;/&quot;，后面是先前捕获的标签 ) # 后缀结束 贪婪与懒惰当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。 有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧： a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。 js运用创建js正则表达式:var expression = /pattern/flags其中模式部分可以是任何简单或复杂的正则表达式。每个表达式都可带有一个或多个标志(flags)，用以标明正则表达式的行为。正则表达式匹配模式支持下列三种。 g:全局模式(global),即模式将用于所有的字符串，而不是发现第一个匹配项就停止匹配。 i:不区分大小写(case-insensitive)模式,即在确定匹配项时忽略模式与字符串的大小写。 m:多行模式(multiline),即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项 RexExp实例方法 exec() 该方法专门为捕获组而设计的。exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组;没有匹配项时返回null，虽然返回的是数组，但包含两个额外的属性：index和input。index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串(如果模式中没有捕获组，则该数组只包含一项) 例子: var text = &quot;mom and dad and baby&quot;; var pattern = /mom( and dad( and baby)?)?/gi; var matches = pattern.exec(text); console.log(matches.input); //mom and dad and baby console.log(matches.index); //0 console.log(matches[0]); //mom and dad and baby console.log(matches[1]); //and dad and baby console.log(matches[2]); //and baby test()它接收一个字符串参数。在模式与该参数匹配的情况下返回true，否则返回false。在只想知道目标字符串与某个模式是否匹配，但不需要知道文本内容的情况下，使用这个方法非常方便。 var text = &quot;000-00-0000&quot;; var pattern = /\\d{3}-\\d{2}-\\d{4}/; if(pattern.test(text)){alert(&quot;The pattern was matched.&quot;)} RegExp构造函数属性 input $_ 最近一次要匹配的字符串 lastMatch $&amp; 最近一次的匹配项 lastParen $+ 最近一次匹配的捕获组 leftContext $` input字符串中lastMatch之前的文本 multiline $* 布尔值，表示是否所有表达式都是多行模式 rightContext $ input字符串中lastMatch之后的文本 例子: var test = &quot;this has been a short summer&quot;; var pattern = /(.)hort/g; if(pattern.test(text)){ console.log(RegExp.input); //this has been a short summer console.log(RegExp.leftContext) //this has been a console.log(RegExp.rightContext) //summer console.log(RegExp.lastMatch); //short console.log(RegExp.lastParen); //s console.log(RegExp.multiline); //false }","tags":[]},{"title":"article title","date":"2017-03-23T14:58:29.000Z","path":"2017/03/23/article-title/","text":"","tags":[]},{"title":"Hello World","date":"2017-03-23T05:05:31.241Z","path":"2017/03/23/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]